interface SaleData {
  readonly id: number;
  readonly amount: number;
  readonly customer: string;
}

interface CustomerData {
  readonly id: number;
  readonly name: string;
  readonly totalSpent: number;
}

interface ProductData {
  readonly name: string;
  readonly sku: string;
  readonly revenue: number;
  readonly unitsSold: number;
}

export class ReportGenerator {
  public generateSalesReport(salesData: SaleData[]): string {
    // DUPLICATE CODE: Header formatting - identical across all reports
    let header = '==========================================\n';
    header += '          COMPANY SALES REPORT           \n';
    header += '==========================================\n';
    header +=
      'Generated on: ' +
      new Date().toISOString().replace('T', ' ').substring(0, 19) +
      '\n';
    header += '==========================================\n\n';

    let content = header;

    // DUPLICATE CODE: Similar data processing with variations
    let total = 0;
    let count = 0;
    let maxValue = 0;
    let minValue = salesData.length === 0 ? 0 : Number.MAX_VALUE;

    for (const sale of salesData) {
      const amount = sale.amount;
      total += amount;
      count++;

      if (amount > maxValue) {
        maxValue = amount;
      }
      if (amount < minValue) {
        minValue = amount;
      }

      content += `Sale #${sale.id}: $${amount.toFixed(2)} (Customer: ${sale.customer})\n`;
    }

    const average = count > 0 ? total / count : 0;

    // DUPLICATE CODE: Summary formatting - similar pattern
    content += '\n--- SALES SUMMARY ---\n';
    content += `Total Sales: $${total.toFixed(2)}\n`;
    content += `Number of Sales: ${count}\n`;
    content += `Average Sale: $${average.toFixed(2)}\n`;
    content += `Highest Sale: $${maxValue.toFixed(2)}\n`;
    content += `Lowest Sale: $${minValue.toFixed(2)}\n`;

    // DUPLICATE CODE: Footer formatting - identical across all reports
    let footer = '\n==========================================\n';
    footer += 'Report generated by ReportGenerator v1.0\n';
    footer += 'Contact: reports@company.com\n';
    footer += '==========================================\n';

    return content + footer;
  }

  public generateCustomerReport(customerData: CustomerData[]): string {
    // DUPLICATE CODE: Header formatting - identical to sales report
    let header = '==========================================\n';
    header += '         COMPANY CUSTOMER REPORT         \n';
    header += '==========================================\n';
    header +=
      'Generated on: ' +
      new Date().toISOString().replace('T', ' ').substring(0, 19) +
      '\n';
    header += '==========================================\n\n';

    let content = header;

    // DUPLICATE CODE: Similar data processing logic with variations
    let total = 0;
    let count = 0;
    let maxValue = 0;
    let minValue = customerData.length === 0 ? 0 : Number.MAX_VALUE;

    for (const customer of customerData) {
      const spentAmount = customer.totalSpent;
      total += spentAmount;
      count++;

      if (spentAmount > maxValue) {
        maxValue = spentAmount;
      }
      if (spentAmount < minValue) {
        minValue = spentAmount;
      }

      content += `Customer: ${customer.name} (ID: ${customer.id}) - Total Spent: $${spentAmount.toFixed(2)}\n`;
    }

    const average = count > 0 ? total / count : 0;

    // DUPLICATE CODE: Summary formatting - almost identical pattern
    content += '\n--- CUSTOMER SUMMARY ---\n';
    content += `Total Revenue: $${total.toFixed(2)}\n`;
    content += `Number of Customers: ${count}\n`;
    content += `Average Spent: $${average.toFixed(2)}\n`;
    content += `Top Customer Spent: $${maxValue.toFixed(2)}\n`;
    content += `Lowest Customer Spent: $${minValue.toFixed(2)}\n`;

    // DUPLICATE CODE: Footer formatting - identical to sales report
    let footer = '\n==========================================\n';
    footer += 'Report generated by ReportGenerator v1.0\n';
    footer += 'Contact: reports@company.com\n';
    footer += '==========================================\n';

    return content + footer;
  }

  public generateProductReport(productData: ProductData[]): string {
    // DUPLICATE CODE: Header formatting - identical to other reports
    let header = '==========================================\n';
    header += '         COMPANY PRODUCT REPORT          \n';
    header += '==========================================\n';
    header +=
      'Generated on: ' +
      new Date().toISOString().replace('T', ' ').substring(0, 19) +
      '\n';
    header += '==========================================\n\n';

    let content = header;

    // DUPLICATE CODE: Similar data processing with slight variations
    let total = 0;
    let count = 0;
    let maxValue = 0;
    let minValue = productData.length === 0 ? 0 : Number.MAX_VALUE;

    for (const product of productData) {
      const revenue = product.revenue;
      total += revenue;
      count++;

      if (revenue > maxValue) {
        maxValue = revenue;
      }
      if (revenue < minValue) {
        minValue = revenue;
      }

      content += `Product: ${product.name} (SKU: ${product.sku}) - Revenue: $${revenue.toFixed(2)} (Sold: ${product.unitsSold})\n`;
    }

    const average = count > 0 ? total / count : 0;

    // DUPLICATE CODE: Summary formatting - same pattern again
    content += '\n--- PRODUCT SUMMARY ---\n';
    content += `Total Product Revenue: $${total.toFixed(2)}\n`;
    content += `Number of Products: ${count}\n`;
    content += `Average Product Revenue: $${average.toFixed(2)}\n`;
    content += `Top Product Revenue: $${maxValue.toFixed(2)}\n`;
    content += `Lowest Product Revenue: $${minValue.toFixed(2)}\n`;

    // DUPLICATE CODE: Footer formatting - identical to other reports
    let footer = '\n==========================================\n';
    footer += 'Report generated by ReportGenerator v1.0\n';
    footer += 'Contact: reports@company.com\n';
    footer += '==========================================\n';

    return content + footer;
  }

  public exportReportToCsv(reportContent: string, filename: string): string {
    // DUPLICATE CODE: Similar export logic - will be used in JSON export too
    const timestamp = new Date()
      .toISOString()
      .replace('T', '_')
      .replace(/[:.]/g, '-')
      .substring(0, 19);
    const fullFilename = `${filename}_${timestamp}.csv`;

    // Convert report content to CSV format
    const lines = reportContent.split('\n');
    let csvContent = '';

    for (const line of lines) {
      if (line.includes(':')) {
        const parts = line.split(':', 2);
        const [key, value] = parts;
        if (key && value !== undefined) {
          csvContent += `"${key.trim()}","${value.trim()}"\n`;
        }
      }
    }

    // DUPLICATE CODE: File writing logic
    let result = 'CSV Export completed successfully!\n';
    result += `Filename: ${fullFilename}\n`;
    result += `Content size: ${csvContent.length} bytes\n`;

    return result;
  }

  public exportReportToJson(reportContent: string, filename: string): string {
    // DUPLICATE CODE: Similar export logic - timestamp and filename generation
    const timestamp = new Date()
      .toISOString()
      .replace('T', '_')
      .replace(/[:.]/g, '-')
      .substring(0, 19);
    const fullFilename = `${filename}_${timestamp}.json`;

    // Convert report content to JSON format
    const lines = reportContent.split('\n');
    const jsonData: Record<string, string> = {};

    for (const line of lines) {
      if (line.includes(':')) {
        const parts = line.split(':', 2);
        const [key, value] = parts;
        if (key && value !== undefined) {
          jsonData[key.trim()] = value.trim();
        }
      }
    }

    const jsonContent = JSON.stringify(jsonData, null, 2);

    // DUPLICATE CODE: File result formatting - identical to CSV export
    let result = 'JSON Export completed successfully!\n';
    result += `Filename: ${fullFilename}\n`;
    result += `Content size: ${jsonContent.length} bytes\n`;

    return result;
  }
}
